const name_big_svg =
  "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDYwOCIgaGVpZ2h0PSI3NjgiIHZpZXdCb3g9IjAgMCAyMzA0IDM4NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNODAuMDMxIDI4MkwxNDUuNTY3IDEwMC4yNEgxOTcuMDIzTDI2Mi41NTkgMjgySDIxNi45OTFMMjA0Ljk1OSAyNDcuNjk2SDEzNy4zNzVMMTI1LjU5OSAyODJIODAuMDMxWk0xNDkuNDA3IDIxMi4zNjhIMTkzLjE4M0wxNzEuNDIzIDE0OC4zNjhMMTQ5LjQwNyAyMTIuMzY4Wk0yODIuMjgzIDI4MlYxMDAuMjRIMzQ5LjYxMUM0MDEuNTc5IDEwMC4yNCA0MjcuMTc5IDExNS42IDQyNy4xNzkgMTUwLjY3MkM0MjcuMTc5IDE3Mi40MzIgNDEzLjM1NSAxODUuNDg4IDM4OC41MjMgMTg4LjA0OEM0MTguOTg3IDE5MC42MDggNDM0Ljg1OSAyMDQuOTQ0IDQzNC44NTkgMjMwLjU0NEM0MzQuODU5IDI2NC4zMzYgNDA5LjUxNSAyODIgMzU5Ljg1MSAyODJIMjgyLjI4M1pNMzI2LjgyNyAyNDYuOTI4SDM2MS4zODdDMzc4LjAyNyAyNDYuOTI4IDM5MC4wNTkgMjQwLjI3MiAzOTAuMDU5IDIyNS45MzZDMzkwLjA1OSAyMTEuODU2IDM3OC4yODMgMjA0Ljk0NCAzNjEuMzg3IDIwNC45NDRIMzI2LjgyN1YyNDYuOTI4Wk0zMjYuODI3IDE3NC4yMjRIMzU0LjIxOUMzNzAuODU5IDE3NC4yMjQgMzgyLjM3OSAxNjguMDggMzgyLjM3OSAxNTUuMDI0QzM4Mi4zNzkgMTQxLjIgMzcxLjM3MSAxMzUuMzEyIDM1NC4yMTkgMTM1LjMxMkgzMjYuODI3VjE3NC4yMjRaTTQ2NC4wMzMgMjgyVjEwMC4yNEg1MDguNTc3VjE3Mi4xNzZINTY5LjUwNVYxMDAuMjRINjE0LjA0OVYyODJINTY5LjUwNVYyMDguNzg0SDUwOC41NzdWMjgySDQ2NC4wMzNaTTY0Mi41MzMgMTAwLjI0SDY4Ny4wNzdWMjgySDY0Mi41MzNWMTAwLjI0Wk03NTkuOTI3IDIxMy4zOTJDNzYwLjE4MyAyMzcuMiA3NjguODg3IDI0OS43NDQgNzg0LjUwMyAyNDkuNzQ0QzgwMC42MzEgMjQ5Ljc0NCA4MDkuMDc5IDIzNy45NjggODA5LjA3OSAyMTUuOTUyVjEwMC4yNEg4NTMuODc5VjIxNS45NTJDODUzLjg3OSAyNTcuOTM2IDgyNS4yMDcgMjg2LjA5NiA3ODMuMjIzIDI4Ni4wOTZDNzQzLjU0MyAyODYuMDk2IDcxNS42MzkgMjU3LjE2OCA3MTUuMzgzIDIxNS42OTZMNzU5LjkyNyAyMTMuMzkyWk04ODQuNzgzIDEwMC4yNEgxMDE1LjM0VjEzNi41OTJIOTI5LjMyN1YxNzIuNjg4SDEwMTIuMjdWMjA5LjA0SDkyOS4zMjdWMjQ1LjY0OEgxMDE3LjM5VjI4Mkg4ODQuNzgzVjEwMC4yNFpNMTA0NS41MyAxMDAuMjRIMTE3Ni4wOVYxMzYuNTkySDEwOTAuMDhWMTcyLjY4OEgxMTczLjAyVjIwOS4wNEgxMDkwLjA4VjI0NS42NDhIMTE3OC4xNFYyODJIMTA0NS41M1YxMDAuMjRaTTEzNDguMzYgMTAwLjI0VjEzNi41OTJIMTI5NC42VjI4MkgxMjQ5LjhWMTM2LjU5MkgxMTk2LjA0VjEwMC4yNEgxMzQ4LjM2Wk0xNDY4LjcxIDIxOS41MzZDMTQ3MS41MiAyMzcuMiAxNDg0LjMyIDI0OC43MiAxNTA1LjMyIDI0OC43MkMxNTIwLjQyIDI0OC43MiAxNTMwLjkyIDI0Mi41NzYgMTUzMC45MiAyMzEuMDU2QzE1MzAuNCAyMTkuMjggMTUyMC42OCAyMTMuMTM2IDE0OTUuMDggMjA2Ljk5MkMxNDUyLjA3IDE5Ni43NTIgMTQyNy40OSAxODAuMzY4IDE0MjcuNDkgMTUxLjE4NEMxNDI3LjQ5IDExNy4zOTIgMTQ1Ni4xNiA5Ni4xNDQgMTQ5OS42OCA5Ni4xNDRDMTU0MC45IDk2LjE0NCAxNTY5LjA2IDEyMS4yMzIgMTU3My40MSAxNTguODY0TDE1MjkuMTIgMTYwLjkxMkMxNTI3LjU5IDE0Mi45OTIgMTUxNS44MSAxMzEuOTg0IDE0OTguNjYgMTMxLjk4NEMxNDgyLjc5IDEzMS45ODQgMTQ3MS43OCAxMzkuOTIgMTQ3Mi44IDE1MS45NTJDMTQ3My41NyAxNjUuMDA4IDE0ODguOTMgMTY5LjYxNiAxNTA3LjExIDE3My45NjhDMTU1MC4xMiAxODIuOTI4IDE1NzUuOTcgMjAwLjU5MiAxNTc1Ljk3IDIzMC4wMzJDMTU3NS45NyAyNjQuODQ4IDE1NDUuNzYgMjg1LjA3MiAxNTA0LjI5IDI4NS4wNzJDMTQ1OC40NyAyODUuMDcyIDE0MjYuNzIgMjYwLjQ5NiAxNDI0LjE2IDIyMS41ODRMMTQ2OC43MSAyMTkuNTM2Wk0xNjAxLjAzIDEwMC4yNEgxNjQ1LjU4VjI4MkgxNjAxLjAzVjEwMC4yNFpNMTY4MC4yOCAxMDAuMjRIMTcyNy4xM0wxNzkzLjE4IDIxNC40MTZWMTAwLjI0SDE4MzcuOThWMjgySDE3ODkuNkwxNzI0LjgzIDE3Mi40MzJWMjgySDE2ODAuMjhWMTAwLjI0Wk0yMDM0Ljg0IDI4MkgyMDA4LjQ3TDIwMDYuNDIgMjU2LjkxMkMxOTk3LjIxIDI3NS4wODggMTk3Ni43MyAyODYuMDk2IDE5NTEuMzggMjg2LjA5NkMxOTAwLjE4IDI4Ni4wOTYgMTg2NC44NSAyNDUuNjQ4IDE4NjQuODUgMTkxLjM3NkMxODY0Ljg1IDEzNi44NDggMTg5OS45MyA5Ni4xNDQgMTk1NC40NSA5Ni4xNDRDMTk5Ni40NCA5Ni4xNDQgMjAyNS42MiAxMjAuNDY0IDIwMzQuMzMgMTYxLjE2OEwxOTg3Ljk5IDE2My4yMTZDMTk4My42NCAxNDMuNzYgMTk3MS42MSAxMzIuNDk2IDE5NTMuNDMgMTMyLjQ5NkMxOTI0LjI1IDEzMi40OTYgMTkxMC42OCAxNTcuMDcyIDE5MTAuNjggMTkxLjM3NkMxOTEwLjY4IDIyNS40MjQgMTkyNC41IDI0OS43NDQgMTk1My40MyAyNDkuNzQ0QzE5NzMuOTEgMjQ5Ljc0NCAxOTg1Ljk0IDIzNi45NDQgMTk4OS41MyAyMTcuNDg4SDE5NTIuOTJWMTg2LjUxMkgyMDM0Ljg0VjI4MlpNMjA2My4yOCAyODJWMTAwLjI0SDIxMDcuODNWMTcyLjE3NkgyMTY4Ljc2VjEwMC4yNEgyMjEzLjNWMjgySDIxNjguNzZWMjA4Ljc4NEgyMTA3LjgzVjI4MkgyMDYzLjI4WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==";
const name_small_svg =
  "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQwMCIgaGVpZ2h0PSI2NTgiIHZpZXdCb3g9IjAgMCAxNDAwIDY1OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNMTA1LjMwMyAyNjRMMTY2Ljc0MyA5My42SDIxNC45ODNMMjc2LjQyMyAyNjRIMjMzLjcwM0wyMjIuNDIyIDIzMS44NEgxNTkuMDYyTDE0OC4wMjMgMjY0SDEwNS4zMDNaTTE3MC4zNDMgMTk4LjcySDIxMS4zODNMMTkwLjk4MyAxMzguNzJMMTcwLjM0MyAxOTguNzJaTTI5NC45MTQgMjY0VjkzLjZIMzU4LjAzNEM0MDYuNzU0IDkzLjYgNDMwLjc1NCAxMDggNDMwLjc1NCAxNDAuODhDNDMwLjc1NCAxNjEuMjggNDE3Ljc5NCAxNzMuNTIgMzk0LjUxNCAxNzUuOTJDNDIzLjA3NCAxNzguMzIgNDM3Ljk1NCAxOTEuNzYgNDM3Ljk1NCAyMTUuNzZDNDM3Ljk1NCAyNDcuNDQgNDE0LjE5NCAyNjQgMzY3LjYzNCAyNjRIMjk0LjkxNFpNMzM2LjY3NCAyMzEuMTJIMzY5LjA3NEMzODQuNjc0IDIzMS4xMiAzOTUuOTU0IDIyNC44OCAzOTUuOTU0IDIxMS40NEMzOTUuOTU0IDE5OC4yNCAzODQuOTE0IDE5MS43NiAzNjkuMDc0IDE5MS43NkgzMzYuNjc0VjIzMS4xMlpNMzM2LjY3NCAxNjIuOTZIMzYyLjM1NEMzNzcuOTU0IDE2Mi45NiAzODguNzU0IDE1Ny4yIDM4OC43NTQgMTQ0Ljk2QzM4OC43NTQgMTMyIDM3OC40MzQgMTI2LjQ4IDM2Mi4zNTQgMTI2LjQ4SDMzNi42NzRWMTYyLjk2Wk00NjUuMzA0IDI2NFY5My42SDUwNy4wNjRWMTYxLjA0SDU2NC4xODRWOTMuNkg2MDUuOTQ0VjI2NEg1NjQuMTg0VjE5NS4zNkg1MDcuMDY0VjI2NEg0NjUuMzA0Wk02MzIuNjQ4IDkzLjZINjc0LjQwOFYyNjRINjMyLjY0OFY5My42Wk03NDIuNzA1IDE5OS42OEM3NDIuOTQ1IDIyMiA3NTEuMTA1IDIzMy43NiA3NjUuNzQ1IDIzMy43NkM3ODAuODY1IDIzMy43NiA3ODguNzg1IDIyMi43MiA3ODguNzg1IDIwMi4wOFY5My42SDgzMC43ODVWMjAyLjA4QzgzMC43ODUgMjQxLjQ0IDgwMy45MDUgMjY3Ljg0IDc2NC41NDUgMjY3Ljg0QzcyNy4zNDUgMjY3Ljg0IDcwMS4xODUgMjQwLjcyIDcwMC45NDUgMjAxLjg0TDc0Mi43MDUgMTk5LjY4Wk04NTkuNzU4IDkzLjZIOTgyLjE1OFYxMjcuNjhIOTAxLjUxOFYxNjEuNTJIOTc5LjI3OFYxOTUuNkg5MDEuNTE4VjIyOS45Mkg5ODQuMDc4VjI2NEg4NTkuNzU4VjkzLjZaTTEwMTAuNDYgOTMuNkgxMTMyLjg2VjEyNy42OEgxMDUyLjIyVjE2MS41MkgxMTI5Ljk4VjE5NS42SDEwNTIuMjJWMjI5LjkySDExMzQuNzhWMjY0SDEwMTAuNDZWOTMuNlpNMTI5NC4zNiA5My42VjEyNy42OEgxMjQzLjk2VjI2NEgxMjAxLjk2VjEyNy42OEgxMTUxLjU2VjkzLjZIMTI5NC4zNlpNMzY5LjQ5MSA1MDMuNDRDMzcyLjEzMSA1MjAgMzg0LjEzMSA1MzAuOCA0MDMuODExIDUzMC44QzQxNy45NzEgNTMwLjggNDI3LjgxMSA1MjUuMDQgNDI3LjgxMSA1MTQuMjRDNDI3LjMzMSA1MDMuMiA0MTguMjExIDQ5Ny40NCAzOTQuMjExIDQ5MS42OEMzNTMuODkxIDQ4Mi4wOCAzMzAuODUxIDQ2Ni43MiAzMzAuODUxIDQzOS4zNkMzMzAuODUxIDQwNy42OCAzNTcuNzMxIDM4Ny43NiAzOTguNTMxIDM4Ny43NkM0MzcuMTcxIDM4Ny43NiA0NjMuNTcxIDQxMS4yOCA0NjcuNjUxIDQ0Ni41Nkw0MjYuMTMxIDQ0OC40OEM0MjQuNjkxIDQzMS42OCA0MTMuNjUxIDQyMS4zNiAzOTcuNTcxIDQyMS4zNkMzODIuNjkxIDQyMS4zNiAzNzIuMzcxIDQyOC44IDM3My4zMzEgNDQwLjA4QzM3NC4wNTEgNDUyLjMyIDM4OC40NTEgNDU2LjY0IDQwNS40OTEgNDYwLjcyQzQ0NS44MTEgNDY5LjEyIDQ3MC4wNTEgNDg1LjY4IDQ3MC4wNTEgNTEzLjI4QzQ3MC4wNTEgNTQ1LjkyIDQ0MS43MzEgNTY0Ljg4IDQwMi44NTEgNTY0Ljg4QzM1OS44OTEgNTY0Ljg4IDMzMC4xMzEgNTQxLjg0IDMyNy43MzEgNTA1LjM2TDM2OS40OTEgNTAzLjQ0Wk00OTMuNTQ3IDM5MS42SDUzNS4zMDdWNTYySDQ5My41NDdWMzkxLjZaTTU2Ny44NDMgMzkxLjZINjExLjc2M0w2NzMuNjgzIDQ5OC42NFYzOTEuNkg3MTUuNjgzVjU2Mkg2NzAuMzIzTDYwOS42MDMgNDU5LjI4VjU2Mkg1NjcuODQzVjM5MS42Wk05MDAuMjM4IDU2Mkg4NzUuNTE4TDg3My41OTggNTM4LjQ4Qzg2NC45NTggNTU1LjUyIDg0NS43NTggNTY1Ljg0IDgyMS45OTggNTY1Ljg0Qzc3My45OTggNTY1Ljg0IDc0MC44NzggNTI3LjkyIDc0MC44NzggNDc3LjA0Qzc0MC44NzggNDI1LjkyIDc3My43NTggMzg3Ljc2IDgyNC44NzggMzg3Ljc2Qzg2NC4yMzggMzg3Ljc2IDg5MS41OTggNDEwLjU2IDg5OS43NTggNDQ4LjcyTDg1Ni4zMTggNDUwLjY0Qzg1Mi4yMzggNDMyLjQgODQwLjk1OCA0MjEuODQgODIzLjkxOCA0MjEuODRDNzk2LjU1OCA0MjEuODQgNzgzLjgzOCA0NDQuODggNzgzLjgzOCA0NzcuMDRDNzgzLjgzOCA1MDguOTYgNzk2Ljc5OCA1MzEuNzYgODIzLjkxOCA1MzEuNzZDODQzLjExOCA1MzEuNzYgODU0LjM5OCA1MTkuNzYgODU3Ljc1OCA1MDEuNTJIODIzLjQzOFY0NzIuNDhIOTAwLjIzOFY1NjJaTTkyNi45MDYgNTYyVjM5MS42SDk2OC42NjZWNDU5LjA0SDEwMjUuNzlWMzkxLjZIMTA2Ny41NVY1NjJIMTAyNS43OVY0OTMuMzZIOTY4LjY2NlY1NjJIOTI2LjkwNloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=";

class NameCanvas {
  constructor(isMobile) {
    this.height = !isMobile ? 384 : 329;
    this.width = !isMobile ? 2304 : 700;
    this.image = !isMobile ? name_big_svg : name_small_svg;
  }

  init() {
    this.canvas = new OffscreenCanvas(this.width, this.height);
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.gl = this.canvas.getContext("webgl", { antialias: true });
    this.clear();

    this.compileShaders();
    this.setProgram();
    this.setBuffer();
    this.setAttributes();
    this.initNameTexture();
    this.initPaintingTexture();
    this.setConstantUniforms();
    this.draw();
  }

  clear() {
    this.gl.clearColor(0, 0, 0, 0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
  }

  compileShaders() {
    this.vertexShader = compileShader(
      this.gl,
      vertexShaderSource,
      this.gl.VERTEX_SHADER
    );
    this.fragmentShader = compileShader(
      this.gl,
      fragmentShaderSource,
      this.gl.FRAGMENT_SHADER
    );
  }

  setProgram() {
    this.program = createProgram(
      this.gl,
      this.vertexShader,
      this.fragmentShader
    );
    this.gl.useProgram(this.program);
  }

  setBuffer() {
    this.cellSize = this.canvas.height * 0.0368;
    const { vertices, indices } = createVerticesAndIndices(
      this.canvas.width,
      this.canvas.height,
      this.cellSize
    );
    this.vertices = vertices;
    this.indices = indices;
    const { vertexBuffer, indexBuffer } = createBuffer(
      this.gl,
      vertices,
      indices
    );
    this.vertexBuffer = vertexBuffer;
    this.indexBuffer = indexBuffer;
  }

  setAttributes() {
    createAttributes(this.gl, this.program);
  }

  initNameTexture() {
    this.texture1 = this.gl.createTexture();
  }

  async setNameTexture(data) {
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture1);
    this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGB,
      this.gl.RGB,
      this.gl.UNSIGNED_BYTE,
      data
    );
    // set the texture parameters
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_WRAP_S,
      this.gl.CLAMP_TO_EDGE
    );
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_WRAP_T,
      this.gl.CLAMP_TO_EDGE
    );
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_MIN_FILTER,
      this.gl.LINEAR
    );
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_MAG_FILTER,
      this.gl.LINEAR
    );
    // set the texture uniform
    const u_nameTextureLocation = this.gl.getUniformLocation(
      this.program,
      "u_nameTexture"
    );
    this.gl.uniform1i(u_nameTextureLocation, 0);
  }

  initPaintingTexture() {
    this.texture2 = this.gl.createTexture();
  }

  setPaintingTexture(data) {
    this.gl.activeTexture(this.gl.TEXTURE1);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture2);
    this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGBA,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      data
    );
    // set the texture parameters
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_WRAP_S,
      this.gl.CLAMP_TO_EDGE
    );
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_WRAP_T,
      this.gl.CLAMP_TO_EDGE
    );
    this.gl.texParameteri(
      this.gl.TEXTURE_2D,
      this.gl.TEXTURE_MIN_FILTER,
      this.gl.LINEAR
    );
    this.gl.uniform1i(
      this.gl.getUniformLocation(this.program, "u_PaintingTexture"),
      1
    );
  }

  setConstantUniforms() {
    // set canvas resolution uniform
    const u_resolutionLocation = this.gl.getUniformLocation(
      this.program,
      "u_resolution"
    );
    this.gl.uniform2f(
      u_resolutionLocation,
      this.canvas.width,
      this.canvas.height
    );
    // set cell size uniform for x axis
    const cellSizeX = this.cellSize * (this.canvas.height / this.canvas.height);
    const u_cellSizeXLocation = this.gl.getUniformLocation(
      this.program,
      "u_cellSizeX"
    );
    this.gl.uniform1f(u_cellSizeXLocation, cellSizeX);
    // set cell size uniform for y axis
    const cellSizeY = this.cellSize;
    const u_cellSizeYLocation = this.gl.getUniformLocation(
      this.program,
      "u_cellSizeY"
    );
    this.gl.uniform1f(u_cellSizeYLocation, cellSizeY);
  }

  setTimeUniform(value) {
    const u_timeLocation = this.gl.getUniformLocation(this.program, "u_time");
    this.gl.uniform1f(u_timeLocation, value);
  }

  setModeUniform(value) {
    const u_modeLocation = this.gl.getUniformLocation(this.program, "u_mode");
    this.gl.uniform1f(u_modeLocation, value);
  }

  draw() {
    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    this.gl.drawElements(
      this.gl.TRIANGLES,
      this.indices.length,
      this.gl.UNSIGNED_SHORT,
      0
    );
  }

  cleanUp() {
    this.gl.deleteProgram(this.program);
    this.gl.deleteShader(this.vertexShader);
    this.gl.deleteShader(this.fragmentShader);
    this.gl.deleteBuffer(this.vertexBuffer);
    this.gl.deleteBuffer(this.indexBuffer);
    this.gl.deleteTexture(this.texture1);
    this.gl.deleteTexture(this.texture2);
  }

  export() {
    return this.canvas.transferToImageBitmap();
  }
}

let nameCanvas = null;

self.onmessage = (event) => {
  const { data } = event;
  if (data.command === "init") {
    nameCanvas = new NameCanvas(data.isMobile);
    nameCanvas.init();
  } else if (data.command === "update") {
    nameCanvas.setTimeUniform(data.time);
    nameCanvas.draw();
    const bitmap = nameCanvas.export();
    self.postMessage({ bitmap }, [bitmap]);
  } else if (data.command === "setModeUniform") {
    nameCanvas.setModeUniform(data.mode);
  } else if (data.command === "setNameTexture") {
    nameCanvas.setNameTexture(data.image);
  } else if (data.command === "setPaintingTexture") {
    nameCanvas.setPaintingTexture(data.bitmap);
  } else if (data.command === "cleanUp") {
    nameCanvas.destroy();
    nameCanvas = null;
  }
};

const vertexShaderSource = `
  attribute vec2 a_position;
  attribute float a_vertexIndex;
  attribute vec2 a_cellIndex;

  uniform vec2 u_resolution;
  uniform float u_time;
  uniform float u_cellSizeX;
  uniform float u_cellSizeY;
  uniform float u_mode;

  uniform sampler2D u_PaintingTexture;

  varying vec2 v_resolution;
  varying float v_time;
  varying vec2 v_texCoord;
  varying float v_mode;

  float random (vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);
  }

  void main() {
    // Calculate the position of the cell in the global space
    vec2 globalPosition = a_position.xy + a_cellIndex * vec2(u_cellSizeX, u_cellSizeY);

    // Normalize the global position to the clip space
    vec2 clipSpacePosition = (globalPosition / u_resolution) * 2.0 - 1.0;

    vec2 pos = clipSpacePosition;

    // calculating texture coordinates
    vec2 texCoord = pos * 0.5 + 0.5;
    vec2 flippedTexCoord = vec2(texCoord.x, 1.0 - texCoord.y);

    // scale u_cellSizeX and u_cellSizeY to canvas size
    float cellSizeX = u_cellSizeX / u_resolution.x;
    float cellSizeY = u_cellSizeY / u_resolution.y;

    // get the color value from the painting texture
    float scale = -0.01;
    if (u_mode == 1.0) {
      scale = (1.0 - texture2D(u_PaintingTexture, flippedTexCoord).r) - 0.01 - 0.33;
    }

    // apply scaling on each vertex by vertex index
    if (a_vertexIndex == 1.0) {
      pos.x += cellSizeX * scale;
      pos.y += cellSizeY * scale;
    } else if (a_vertexIndex == 2.0) {
      pos.x -= cellSizeX * scale;
      pos.y += cellSizeY * scale;
    } else if (a_vertexIndex == 3.0) {
      pos.x += cellSizeX * scale;
      pos.y -= cellSizeY * scale;
    } else if (a_vertexIndex == 4.0) {
      pos.x -= cellSizeX * scale;
      pos.y -= cellSizeY * scale;
    } else {
      pos.x += 0.0;
      pos.y += 0.0;
    }

    gl_Position = vec4(pos, 0, 1);

    // gl_Position = vec4(a_position, 0.0, 1.0);

    // Pass the data to the fragment shader
    v_resolution = u_resolution;
    v_time = u_time;
    v_texCoord = flippedTexCoord;
    v_mode = u_mode;
  }
`;

const fragmentShaderSource = `
  precision mediump float;

  varying vec2 v_resolution;
  varying float v_time;
  varying vec2 v_texCoord;
  varying float v_mode;

  uniform sampler2D u_nameTexture;
  uniform sampler2D u_PaintingTexture;

  void warpingTextureImage(out vec4 fragColor, in vec2 fragCoord) {
    float effectDensity = 8.0;
    float effectScale = 0.3;
    float scaledTime = v_time * 0.0025;

    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/v_resolution.xy;

    // scale y to the aspect ratio
    uv.y *= v_resolution.y / v_resolution.x;

    // effect density/repeat
    uv = uv * effectDensity;

    for(float k = 1.0; k < 8.0; k += 1.0){
      uv.x += effectScale * cos(uv.y * k + scaledTime * k) - scaledTime * k * 10.0;
      uv.y += effectScale * sin(uv.x * k + scaledTime * k) - scaledTime * k * 2.5;
    }

    // Time varying pixel color
    vec3 col = 0.5 + 0.5*sin(v_time+uv.xyx+vec3(2,4,0));

    // Output to screen
    fragColor = vec4(col,1.0);
}

  void main() {
      // main texture
      vec4 nameTexture = texture2D(u_nameTexture, v_texCoord);
      // cropping out the black part
      if (v_mode == 0.0 && nameTexture.rgb == vec3(0.0, 0.0, 0.0)) {
        discard;
      }

      // gradient texture
      vec4 paintingTexture = texture2D(u_PaintingTexture, v_texCoord);

      // warping texture
      vec4 warpingTexture;
      warpingTextureImage(warpingTexture, gl_FragCoord.xy);

      // mix grayscale and normal color based on painting texture
      float luminance = dot(warpingTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
      vec3 grayScaledColor = vec3(luminance, luminance, luminance);
      vec3 finalColor = mix(grayScaledColor, warpingTexture.rgb, paintingTexture.r);

      // Increase contrast
      float contrast = 1.5; // Adjust this value to increase or decrease contrast
      finalColor = (finalColor - 0.5) * contrast + 0.5;

      gl_FragColor = vec4(finalColor, 1.0);
  }
`;

function compileShader(gl, source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("Shader compilation error:", gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Program linking error:", gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  return program;
}

function createBuffer(gl, vertices, indices) {
  // Create a single buffer that contains the vertices for all cells
  let vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  // Create an index buffer that specifies the vertices for each cell
  let indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(
    gl.ELEMENT_ARRAY_BUFFER,
    new Uint16Array(indices),
    gl.STATIC_DRAW
  );
  return { vertexBuffer, indexBuffer };
}

function createVerticesAndIndices(canvasWidth, canvasHeight, cellSize) {
  let vertices = [];
  let indices = [];
  let cellIndex = 0;
  for (let i = 0; i < canvasHeight / cellSize; i++) {
    for (let j = 0; j < canvasWidth / cellSize; j++) {
      // normalize x and y between -1 and 1
      let x = (j * cellSize * 2) / canvasWidth - 1;
      let y = (i * cellSize * 2) / canvasHeight - 1;

      const cellIndexX = j;
      const cellIndexY = i;

      vertices.push(
        x,
        y,
        1,
        cellIndexX,
        cellIndexY, // Vertex 1
        x + cellSize,
        y,
        2,
        cellIndexX,
        cellIndexY, // Vertex 2
        x,
        y + cellSize,
        3,
        cellIndexX,
        cellIndexY, // Vertex 3
        x + cellSize,
        y + cellSize,
        4,
        cellIndexX,
        cellIndexY // Vertex 4
      );
      indices.push(
        cellIndex * 4 + 0,
        cellIndex * 4 + 1,
        cellIndex * 4 + 2,
        cellIndex * 4 + 2,
        cellIndex * 4 + 1,
        cellIndex * 4 + 3
      );
      cellIndex++;
    }
  }

  return { vertices, indices };
}

function createAttributes(gl, program) {
  // Set up vertex attribute
  var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(positionAttributeLocation);
  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 20, 0);

  // set up vertex index attribute
  var vertexIndexAttributeLocation = gl.getAttribLocation(
    program,
    "a_vertexIndex"
  );
  gl.enableVertexAttribArray(vertexIndexAttributeLocation);
  gl.vertexAttribPointer(
    vertexIndexAttributeLocation,
    1,
    gl.FLOAT,
    false,
    20,
    8
  );

  // set up vertex index attribute
  var cellIndexAttributeLocation = gl.getAttribLocation(program, "a_cellIndex");
  gl.enableVertexAttribArray(cellIndexAttributeLocation);
  gl.vertexAttribPointer(
    cellIndexAttributeLocation,
    2,
    gl.FLOAT,
    false,
    20,
    12
  );
}
